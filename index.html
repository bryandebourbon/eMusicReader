<!-- 
TODO:

ASSETS
dotted note
rest support
natural, sharps and flats
clefs
key signature support


MVP FUNCTIONALITY
fix pinch should zoom like cmd+
swipe auto scrolls to satisfying position
buttons for "next page"
save melodies/files somewhere
font editor make stems and notes as big as u want

STRETCH GOALS
play notes
lyrics on bottom
chords on top 
listening for notes and plotting them

-->

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<!-- <meta http-equiv="refresh" content="10"> -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

<title>Music Note</title>
<!--
..######...######...######.
.##....##.##....##.##....##
.##.......##.......##......
.##........######...######.
.##.............##.......##
.##....##.##....##.##....##
..######...######...######.
###########################
-->
<style>
:root {
  --space-color: white;
  --line-color: black;
  --note-color: black;
  --tie-color: red;

  --staff-width: 1.6em;
  --space-height: 1em;
  --line-height: 0.16em;

  --note-height: 0.775em;
  --note-width: 1.033em;

  --stem-height: 2.33em;
  --stem-width: 0.1em;

  --flag-height: 0.83em;
  --flag-width: 0.3em;

  --tie-thickness:0;
}

@media (prefers-color-scheme: dark) {
  
  :root {
    --space-color: black;
    --line-color: white;
    --note-color: white;
  }

  body {
    background-color: black;
  }
  
}

.dark-mode {
  --space-color: black;
  --line-color: white;
  --note-color: white;
}

body.dark-mode {
  background-color: black;
}
html, body {
  display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
  margin: 0;
  padding: 0;
  height: 100%; 
  width: 100%;  
  overflow: hidden;
   -webkit-touch-callout: none;  /* iOS Safari */
  -webkit-user-select: none;    /* Safari */
  -khtml-user-select: none;     /* Konqueror HTML */
  -moz-user-select: none;       /* Old versions of Firefox */
  -ms-user-select: none;        /* IE/Edge */
  user-select: none;            /* Non-prefixed version, currently supported by Chrome, Opera and Firefox */
}

svg {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}
.controls {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  display: flex;
  flex-wrap: wrap;
  gap: 4px;
  background-color: var(--space-color);
  padding: 4px;
  z-index: 10;
}
#settingsModal.modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0,0,0,0.5);
  display: none;
  align-items: center;
  justify-content: center;
}
#settingsModal.modal.open {
  display: flex;
}
#settingsModal .modal-content {
  background-color: var(--space-color);
  padding: 20px;
  border: 1px solid var(--line-color);
  max-height: 90vh;
  overflow-y: auto;
}
#settingsModal .modal-content label {
  display: block;
  margin: 5px 0;
}
#xmlInput {
  position: static;
}
  
.sheet {
  padding: 40px;
  position:relative;
  display: flex;
    flex-wrap: wrap;
    overflow-y: auto;
}
.measure {
  position: relative;
  display: flex;
    flex-wrap: wrap;
    overflow: hidden;
  flex-grow:1;
}
.beam {
  position:relative;
  display: flex;
    flex-wrap: wrap;
    overflow: hidden;
  z-index: 4;
}
.staff {
  flex-grow:1;
  position: relative;
  display: flex;
    flex-direction: column;
    justify-content: space-between;
  min-width: var(--staff-width);
  /* margin-bottom: var(--space-height); */
  z-index: 0;
  margin:0;
}

.line {
  background-color: var(--line-color);
  height: var(--line-height);
  position: relative;
  display: flex;
    justify-content: center;
}
.line > .note {
  position: absolute;
  top: calc(var(--space-height)* -0.3);
}

.space {
  height: var(--space-height);
  position: relative;
  display: flex;
    justify-content: center;
}
.space > .note {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
}
.stem-down {
  rotate: 180deg !important;
}

.stem-up {
  rotate: 0deg !important;
}

.high > .note {
  rotate: 180deg;
}
.high > .line {
  top: 0
}
.high.space > .note {
  top:  calc(var(--space-height) * 0.1);
  transform: translateY(0);
}

.ledger {
  background-color: var(--space-color);
}
.ledger:has(div){
  background-color: var(--line-color);
  /* height: 0.1em; */
}

/* <!--
###  #  ### ###  ##
# # # #  #  #   #
# # # #  #  ##   #
# # # #  #  #     #
# #  #   #  ### ##
--> */
.note {
  position: relative;
  width: var(--note-width);
  height: var(--note-height);
  z-index: 2;
}
.note > .head {
  position: absolute;
  width: var(--note-width);
  height: var(--note-height);
  rotate: -27deg;
  background-color: var(--note-color);
  border-radius: 50%;
}
.note.whole > .head {
  position: absolute;
  width: var(--note-width);
  height: var(--note-height);
  background-color: var(--note-color);
  border-radius: 50%;
  rotate: 0deg;
}

.note.half > .head::after {
  content: "";
  position: absolute;
  width: 80%;
  height: 50%;
  border-radius: 50%;
  background-color: var(--space-color);
  z-index: 2;
  top: calc(var(--space-height) * 0.2);
  left: calc(var(--space-height) * 0.1);
}
.note.whole > .head::after {
  content: "";
  position: absolute;
  width: 60%;
  height: 50%;
  border-radius: 50%;
  background-color: var(--space-color);
  z-index: 2;
  top: 25%;
  left: 21%;
  rotate: 40deg;
}
.line > .note.whole ::before {
  content: "";
  background-color: var(--line-color);
  height: var(--line-height);
  position: absolute;
  width: 100%;
  top: calc(var(--space-height) * 0.3);
  rotate: 0deg;
  z-index: 3;
}

.line > .note.half ::before {
  content: "";
  background-color: var(--line-color);
  height: var(--line-height);
  position: absolute;
  width: 100%;
  top: calc(var(--space-height) * 0.3);
  rotate: 27deg;
  z-index: 3;
}

/* <!--
 ## ### ### # #
#    #  #   ###
 #   #  ##  ###
  #  #  #   # #
##   #  ### # #
--> */
.stem {
  position: absolute;
  right: 3%;
  top: calc(var(--space-height) * -2);;
  width: var(--stem-width);
  height: var(--stem-height);
  background-color: var(--note-color);
  z-index: 1;
}
.note.whole > .stem {
  display:none;
}

/* <!--
### #    #   ##
#   #   # # #
##  #   ### # #
#   #   # # # #
#   ### # #  ##
--> */
.flag {
  display:none;
}
.note.sixteenth,
.note.eighth > .flag {
  display:block;
  background-color: var(--note-color);
  position: absolute;
  right: calc(var(--space-height) * -0.233);
  bottom: calc(var(--space-height) * 1.93);
  width: var(--flag-width);
  height: var(--flag-height);
  border-top-right-radius: calc(var(--space-height) * 0.5);
  border-bottom-right-radius:calc(var(--space-height) *  0.5);
}






.measure-bar {
  display: flex;
  flex-direction: column;
}
.measure-bar > div {
  display: block;
  width: calc(var(--space-height) * 0.3);
  height: calc(var(--space-height) * 4.83);
  background-color: var(--line-color);
  margin-top: calc(var(--space-height) * 1.1667);
  margin-bottom: calc(var(--space-height) * 1);
  position: relative;
}

.lineContainer {
  position: absolute;
  pointer-events: none;
  top: 0;
  left: 0;
}

.note.phrase-highlight {
  outline: 2px solid red;
}

/* .tie-under {
    border-color: green blue red yellow;
    border-radius: 50px 50px 50px 50px;
} */

</style>
</head>
<!--
.##.....##.########.##.....##.##......
.##.....##....##....###...###.##......
.##.....##....##....####.####.##......
.#########....##....##.###.##.##......
.##.....##....##....##.....##.##......
.##.....##....##....##.....##.##......
.##.....##....##....##.....##.########
######################################
-->
<body onload="init();" style="touch-action:none" >
<div class="controls">
  <input
    id="xmlInput"
    type="file"
    onchange="fileHandler(event)"/>
  <button id="useDefaultFile" title="Use Default File"><i class="fa-solid fa-file-lines"></i></button>
  <button onclick="addStaffBlock()" title="Add Staff"><i class="fa-solid fa-plus"></i></button>
  <button id="zoomIn" title="Zoom In"><i class="fa-solid fa-magnifying-glass-plus"></i></button>
  <button id="zoomOut" title="Zoom Out"><i class="fa-solid fa-magnifying-glass-minus"></i></button>
  <button id="refreshTies" title="Refresh Ties"><i class="fa-solid fa-arrows-rotate"></i></button>
  <button id="renderBeams" title="Render Beams"><i class="fa-solid fa-bars-staggered"></i></button>
  <button id="openSettings" title="Settings"><i class="fa-solid fa-gear"></i></button>
  <button id="toggleDarkMode" title="Toggle dark mode"><i class="fa-solid fa-moon"></i></button>
  <select id="phraseSelect" title="Detected Melodies"></select>
</div>

<div class="sheet" id="zoomContainer"></div>

<!-- Settings Modal -->
<div id="settingsModal" class="modal">
  <div class="modal-content">
    <button id="closeSettings" title="Close"><i class="fa-solid fa-xmark"></i></button>
    <h3>Settings</h3>
    <label>Space Color <input type="color" id="spaceColor"></label>
    <label>Line Color <input type="color" id="lineColor"></label>
    <label>Note Color <input type="color" id="noteColor"></label>
    <label>Tie Color <input type="color" id="tieColor"></label>
    <label>Staff Width <input type="range" id="staffWidth" min="0.5" max="3" step="0.1"></label>
    <label>Space Height <input type="range" id="spaceHeight" min="0.5" max="2" step="0.1"></label>
    <label>Line Height <input type="range" id="lineHeight" min="0.05" max="0.5" step="0.01"></label>
    <label>Note Height <input type="range" id="noteHeight" min="0.5" max="2" step="0.1"></label>
    <label>Note Width <input type="range" id="noteWidth" min="0.5" max="2" step="0.1"></label>
  </div>
</div>

<section class="assets"style="display:none;">

<div class="measure">
  <div class="measure-bar">
    <div></div>
    <div></div>
  </div>
</div>
<div class="staff" 
  ondrop="dropHandler(event)" 
  ondragover="dragHandler(event)" 
  ondragleave="dragHandler(event)" >
    <div class="line  a5 high ledger"></div>
    <div class="space g5 high"></div>
    <div class="line  f5 high"></div>
    <div class="space e5 high"></div>
    <div class="line  d5 high"></div>
    <div class="space c5 high"></div>
    <div class="line  b4 high"></div>
    <div class="space a4"></div>
    <div class="line  g4"></div>
    <div class="space f4"></div>
    <div class="line  e4"></div>
    <div class="space d4"></div>
    <div class="line  c4 ledger"></div>
    <div class="space b3 high"></div>
    <div class="line  a3 high"></div>
    <div class="space g3 high"></div>
    <div class="line  f3 high"></div>
    <div class="space e3 high"></div>
    <div class="line  d3 high"></div>
    <div class="space c3"></div>
    <div class="line  b2"></div>
    <div class="space a2"></div>
    <div class="line  g2"></div>
    <div class="space f2"></div>
    <div class="line  e2 ledger"></div>
</div>
<div class="note"
  ondragstart="dragstartHandler(event)"
  ondblclick="showMenu(event)"
  draggable="true">
    <div class="head"></div>
    <div class="stem"></div>
    <div class="flag"></div>
</div> 
<div class="beam"></div>

<svg class="lineContainer"></svg>

<!-- <div class="menu"
  onclick="">
    <div class="option">Sharp</div>
    <div class="option">Flat</div>
    <div class="option">Whole</div>
    <div class="option">Half</div>
    <div class="option">Quarter</div>
    <div class="option">Eighth</div>
    <div class="option">Sixteenth</div>
    <div class="option">Delete</div>
</div> -->
</section>
</body>
<script>
// Global vars to cache event state
let evCache = [];
let prevDiff = -1;

// Global arrays for melody pattern detection
let noteSteps = [];
let noteElements = [];
let detectedPatterns = {};

function init() {
// Install event handlers for the pointer target
  const el = document.getElementById("zoomContainer");
  el.onpointerdown = pointerdownHandler;
  el.onpointermove = pointermoveHandler;
  el.onpointerup = pointerupHandler;
  el.onpointercancel = pointerupHandler;
  el.onpointerout = pointerupHandler;
  el.onpointerleave = pointerupHandler;
}
function pointerdownHandler(ev) {
  evCache.push(ev);
  console.log("pointerDown", ev);
  console.log(evCache)
}

function pointermoveHandler(ev) {

  console.log("pointerMove", ev);

  // If two pointers are down, check for pinch gestures
  if (evCache.length === 2) {
    // Calculate the distance between the two pointers
    const curDiff = Math.abs(evCache[0].clientX - evCache[1].clientX);
console.log(curDiff)
console.log(prevDiff)
    if (prevDiff > 0) {
      if (curDiff > 70) {
        // The distance between the two pointers has increased
        console.log("Pinch moving OUT -> Zoom in", ev);
          zoomLevel += 0.1;
        zoomContainer.style.zoom = zoomLevel;
        tieify();
      }
      if (curDiff < prevDiff) {
        // The distance between the two pointers has decreased
        console.log("Pinch moving IN -> Zoom out", ev);
          zoomLevel -= 0.1;
  zoomContainer.style.zoom = zoomLevel;
  tieify();
      }
    } 
      prevDiff = curDiff;
    

    // Cache the distance for the next move event
    
  }
}
  
function pointerupHandler(ev) {
  prevDiff = -1;
  evCache = []
  console.log(evCache)
}




  
const assets = document.querySelector('.assets')

const zoomContainer = document.getElementById('zoomContainer');
let zoomLevel = 1;

document.getElementById('zoomIn').addEventListener('click', () => {
  zoomLevel += 0.1;
  zoomContainer.style.zoom = zoomLevel;
  tieify();
});

document.getElementById('zoomOut').addEventListener('click', () => {
  zoomLevel -= 0.1;
  zoomContainer.style.zoom = zoomLevel;
  tieify();

});

document.getElementById('refreshTies').addEventListener('click', () => {
  tieify();
});

document.getElementById('renderBeams').addEventListener('click', () => {
  requestAnimationFrame(() => {
    beamify();
    tieify();
  });
});

document.getElementById('useDefaultFile').addEventListener('click', function() {
  fetch('ddd.xml') // Adjust the path if your XML file is in a specific directory
    .then(response => response.text())
    .then(data => {
      const parser = new DOMParser();
      const xmlDoc = parser.parseFromString(data,"text/xml");
      populateStaffFromMusicXML(xmlDoc);
    })
    .catch(error => console.error('Error loading the default file:', error));
});

 
/*

##  ###  #  # #  ##
# # #   # # ### #
##  ##  ### ###  #
# # #   # # # #   #
##  ### # # # # ##

*/

function drawLine(flag1, flagn, parent, isDown ) {
  if (flag1 === undefined) return;
  const rect1=flag1.getBoundingClientRect();
  const rect2=flagn.getBoundingClientRect();
  const parentRect = parent.getBoundingClientRect();

  const svg = document.querySelector('.assets .lineContainer').cloneNode(true);
  svg.id = Math.random();

  const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');

  
 const lineColor = getComputedStyle(document.documentElement).getPropertyValue('--line-color').trim();;
  
  if (!isDown) {
    line.setAttribute('x1', (rect1.left) - parentRect.left);
    line.setAttribute('y1', (rect1.top) - parentRect.top);
    line.setAttribute('x2', (rect2.left) - parentRect.left);
    line.setAttribute('y2', (rect2.top ) - parentRect.top);
    
    line.setAttribute('stroke', lineColor);
    line.setAttribute('stroke-width', '10');
  } else {
    line.setAttribute('x1', (rect1.right) - parentRect.left);
    line.setAttribute('y1', (rect1.bottom) - parentRect.top);
    line.setAttribute('x2', (rect2.right) - parentRect.left);
    line.setAttribute('y2', (rect2.bottom ) - parentRect.top);
    
    line.setAttribute('stroke', lineColor);
    line.setAttribute('stroke-width', '20');
  }
  
  svg.appendChild(line);
  parent.appendChild(svg);

  return line;
}
  
function tieify() {
  // Clear existing ties
  const existingTies = document.querySelectorAll('.sheet .tieDiv');
  existingTies.forEach(tie => tie.remove());

  const notes = document.querySelectorAll('.sheet .note');
  const tiePairs = {};

  notes.forEach(note => {
    Array.from(note.attributes).forEach(attr => {
      if (attr.name.startsWith('data-tie')) {
        const number = attr.name.replace('data-tie', '');
        const type = attr.value;
        if (!tiePairs[number]) tiePairs[number] = { start: [], stop: [] };
        tiePairs[number][type].push(note);
      }
    });
  });

  Object.values(tiePairs).forEach(pair => {
    const count = Math.min(pair.start.length, pair.stop.length);
    for (let i = 0; i < count; i++) {
      const startNote = pair.start[i];
      const stopNote = pair.stop[i];
      const start = startNote.getBoundingClientRect();
      const stop = stopNote.getBoundingClientRect();

      const tieDiv = document.createElement('div');
      tieDiv.className = 'tieDiv'; // Add a class name for easy removal later
      tieDiv.style.position = 'absolute';
      tieDiv.style.height = '2em';

      tieDiv.style.borderStyle = 'solid';
      tieDiv.style.borderWidth = '0.5em';

      const orientation = startNote.classList.contains('tie-under') ? 'under' : 'over';
      if (orientation === 'under') {
        tieDiv.style.borderColor = 'red transparent transparent transparent';
        tieDiv.style.borderRadius = '100px 100px 0px 0px';
        tieDiv.style.top = `${start.bottom + window.scrollY - 10}px`;
      } else {
        tieDiv.style.borderColor = 'transparent transparent red transparent';
        tieDiv.style.borderRadius = '0px 0px 100px 100px';
        tieDiv.style.top = `${start.top + window.scrollY - 30}px`;
      }
      tieDiv.style.left = `${start.left + window.scrollX}px`;

      tieDiv.style.width = `${stop.left - start.left}px`;

      document.querySelector('.sheet').appendChild(tieDiv);
    }
  });
}



function beamify() {
  const beamElements = document.querySelectorAll('.beam');
  const stemXCoords = []; 

  beamElements.forEach(beamGroup => {
    const notes=beamGroup.querySelectorAll('.note');
    const flags=beamGroup.querySelectorAll('.flag');
    const stems=beamGroup.querySelectorAll('.stem');

    const beamRect = beamGroup.getBoundingClientRect();

    const firstFlag = flags[0];
    const lastFlag = flags[flags.length - 1];

    let svg;

    let containsDown = false;
    notes.forEach(note => {
      if (note.classList.contains("stem-down")) {
        containsDown = true;
      }
    });

    if (firstFlag && lastFlag) {
      svg = drawLine(firstFlag, lastFlag, beamGroup, containsDown);
    }

    // Remove flags
    flags.forEach(flag => {
      flag.remove();
    });

    const line = beamGroup.querySelector('line');
    if (line == null) return;
    // console.log(line);
    const lineY1 = parseFloat(line.getAttribute('y1'));
    const lineY2 = parseFloat(line.getAttribute('y2'));
    const lineX1 = parseFloat(line.getAttribute('x1'));
    const lineX2 = parseFloat(line.getAttribute('x2'));

    const lineSlope = (lineY2 - lineY1) / (lineX2 - lineX1);

    notes.forEach(note => {
      const stems = note.querySelector('.stem');
      const rect = stems.getBoundingClientRect();
      const xCoord = rect.left - beamRect.left;
      stemXCoords.push(xCoord);

      const lineYAtX = lineY1 + lineSlope * (xCoord - lineX1);

      const difference = (rect.bottom - beamRect.top) - lineYAtX;

      if (difference < 0) {
        const newLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        newLine.setAttribute('x1', xCoord);
        newLine.setAttribute('y1', rect.bottom - beamRect.top);
        newLine.setAttribute('x2', xCoord);
        newLine.setAttribute('y2', lineYAtX);
        newLine.setAttribute('stroke', 'red');
        newLine.setAttribute('stroke-width', '20');
        beamGroup.querySelector('svg').appendChild(newLine);
      }
    });

  });
}

// # # # #  ## ###  ##     # # # # #
// ### # # #    #  #       # # ### #
// ### # #  #   #  #   ###  #  ### #
// # # # #   #  #  #       # # # # #
// # # ### ##  ###  ##     # # # # ###
function appendMeasureNotes(measure, measureDiv) {
  let beamDiv = null;
  let prevStaffBlock = null;
  const notes = measure.getElementsByTagName("note");
  for (let j = 0; j < notes.length; j++) {
    const isChord = notes[j].getElementsByTagName("chord")[0];
    const stepElement = notes[j].getElementsByTagName("step")[0];
    const octaveElement = notes[j].getElementsByTagName("octave")[0];
    const typeElement = notes[j].getElementsByTagName("type")[0];
    const stemElement = notes[j].getElementsByTagName("stem")[0];
    const beamElement = notes[j].getElementsByTagName("beam")[0];
    const tiedElements = notes[j].getElementsByTagName("tied");

    if (stepElement && octaveElement && typeElement) {
      const step = stepElement.textContent.toLowerCase();
      const octave = octaveElement.textContent;
      const noteType = typeElement.textContent;
      const musicNote = `${step}${octave}`;

      let staffBlock;
      if (isChord) {
        staffBlock = plotStaffBlock(prevStaffBlock, musicNote, noteType);
      } else {
        staffBlock = genStaffBlock(musicNote, noteType);
      }

      if (staffBlock instanceof Node) {
        const noteDiv = staffBlock.querySelector('.note');
        if (stemElement) {
          const stemDirection = stemElement.textContent;
          if (noteDiv) {
            noteDiv.classList.add(`stem-${stemDirection}`);
          }
        }

        if (tiedElements && tiedElements.length) {
          for (let t = 0; t < tiedElements.length; t++) {
            const tie = tiedElements[t];
            const number = tie.getAttribute('number') || '1';
            const orientation = tie.getAttribute('orientation');
            const type = tie.getAttribute('type');

            noteDiv.dataset[`tie${number}`] = type;
            if (orientation) {
              noteDiv.classList.add(`tie-${orientation}`);
            }
          }
        }

        if (beamElement) {
          const beamType = beamElement.textContent;
          if (beamType === "begin") {
            beamDiv = document.querySelector('.assets .beam').cloneNode(true);
          }
          if (beamDiv && beamDiv instanceof Node) {
            beamDiv.appendChild(staffBlock);
          }
          if (beamType === "end" && beamDiv) {
            measureDiv.appendChild(beamDiv);
            beamDiv = null;
          }
        } else {
          if (beamDiv && beamDiv instanceof Node) {
            measureDiv.appendChild(beamDiv);
            beamDiv = null;
          }
          if (!isChord) {
            measureDiv.appendChild(staffBlock);
          }
        }
        if (!isChord) {
          prevStaffBlock = staffBlock;
        }
      }
    }
  }
  return measureDiv;
}

function parseMeasureNotes(measure) {
  const result = [];
  let currentTime = 0;

  Array.from(measure.children).forEach(el => {
    if (el.tagName === 'note') {
      const durationEl = el.getElementsByTagName('duration')[0];
      const duration = durationEl ? parseInt(durationEl.textContent) : 0;

      const stepEl = el.getElementsByTagName('step')[0];
      const octaveEl = el.getElementsByTagName('octave')[0];
      const typeEl = el.getElementsByTagName('type')[0];
      const stemEl = el.getElementsByTagName('stem')[0];
      const beamEl = el.getElementsByTagName('beam')[0];
      const tiedEls = el.getElementsByTagName('tied');
      const isChord = el.getElementsByTagName('chord')[0];

      if (stepEl && octaveEl && typeEl) {
        const ties = [];
        if (tiedEls && tiedEls.length) {
          for (let t = 0; t < tiedEls.length; t++) {
            ties.push({
              number: tiedEls[t].getAttribute('number') || '1',
              orientation: tiedEls[t].getAttribute('orientation'),
              type: tiedEls[t].getAttribute('type')
            });
          }
        }

        result.push({
          time: currentTime,
          step: stepEl.textContent.toLowerCase(),
          octave: octaveEl.textContent,
          noteType: typeEl.textContent,
          isChord: !!isChord,
          stem: stemEl ? stemEl.textContent : null,
          beam: beamEl ? beamEl.textContent : null,
          ties
        });
      }

      if (!isChord) {
        currentTime += duration;
      }
    } else if (el.tagName === 'forward') {
      const dur = el.getElementsByTagName('duration')[0];
      if (dur) currentTime += parseInt(dur.textContent);
    } else if (el.tagName === 'backup') {
      const dur = el.getElementsByTagName('duration')[0];
      if (dur) currentTime -= parseInt(dur.textContent);
    }
  });

  return result;
}

function appendInterleavedNotes(notesByPart, measureDiv) {
  const beamDivs = new Array(notesByPart.length).fill(null);
  const prevBlocks = new Array(notesByPart.length).fill(null);

  const allNotes = [];
  notesByPart.forEach((notes, idx) => {
    notes.forEach(n => allNotes.push(Object.assign({ part: idx }, n)));
  });

  allNotes.sort((a, b) => {
    if (a.time === b.time) return a.part - b.part;
    return a.time - b.time;
  });

  allNotes.forEach(n => {
    const part = n.part;
    let beamDiv = beamDivs[part];
    let prevStaffBlock = prevBlocks[part];

    const musicNote = `${n.step}${n.octave}`;
    let staffBlock;
    if (n.isChord) {
      staffBlock = plotStaffBlock(prevStaffBlock, musicNote, n.noteType);
    } else {
      staffBlock = genStaffBlock(musicNote, n.noteType);
    }

    if (staffBlock instanceof Node) {
      const noteDiv = staffBlock.querySelector('.note');
      if (n.stem && noteDiv) {
        noteDiv.classList.add(`stem-${n.stem}`);
      }

      if (noteDiv) {
        noteDiv.dataset.index = noteSteps.length;
        noteSteps.push(n.step);
        noteElements.push(noteDiv);
      }

      if (n.ties && n.ties.length) {
        n.ties.forEach(tie => {
          noteDiv.dataset[`tie${tie.number}`] = tie.type;
          if (tie.orientation) {
            noteDiv.classList.add(`tie-${tie.orientation}`);
          }
        });
      }

      if (n.beam) {
        if (n.beam === 'begin') {
          beamDiv = document.querySelector('.assets .beam').cloneNode(true);
        }
        if (beamDiv && beamDiv instanceof Node) {
          beamDiv.appendChild(staffBlock);
        }
        if (n.beam === 'end' && beamDiv) {
          measureDiv.appendChild(beamDiv);
          beamDiv = null;
        }
      } else {
        if (beamDiv && beamDiv instanceof Node) {
          measureDiv.appendChild(beamDiv);
          beamDiv = null;
        }
        if (!n.isChord) {
          measureDiv.appendChild(staffBlock);
        }
      }

      if (!n.isChord) {
        prevStaffBlock = staffBlock;
      }
    }

    beamDivs[part] = beamDiv;
    prevBlocks[part] = prevStaffBlock;
  });

  beamDivs.forEach(beamDiv => {
    if (beamDiv && beamDiv instanceof Node) {
      measureDiv.appendChild(beamDiv);
    }
  });

  return measureDiv;
}

function populateStaffFromMusicXML(xmlDoc) {
  noteSteps = [];
  noteElements = [];
  detectedPatterns = {};

  const parts = xmlDoc.getElementsByTagName("part");
  const sheet = document.querySelector('.sheet');
  sheet.innerHTML = '';

  const measuresByPart = Array.from(parts).map(p => p.getElementsByTagName("measure"));
  const maxMeasures = Math.max(...measuresByPart.map(m => m.length));

  const parsed = measuresByPart.map(measures => Array.from(measures).map(m => parseMeasureNotes(m)));

  for (let i = 0; i < maxMeasures; i++) {
    let measureDiv = document.querySelector('.assets .measure').cloneNode(true);

    const notesForMeasure = parsed.map(p => p[i] || []);
    measureDiv = appendInterleavedNotes(notesForMeasure, measureDiv);

    sheet.appendChild(measureDiv);
  }
  // Ensure layout is calculated before drawing beams and ties
  requestAnimationFrame(() => {
    beamify();
    tieify();
    detectPatternsFromSteps();
  });
}


//  ## ###  #  ### ### ##  #    #   ## # #
// #    #  # # #   #   # # #   # # #   # #
//  #   #  ### ##  ##  ##  #   # # #   ##
//   #  #  # # #   #   # # #   # # #   # #
// ##   #  # # #   #   ##  ###  #   ## # #

function genStaffBlock(pitchSpace='e4', noteType='quarter') {
  const staffClone = assets.querySelector('.staff').cloneNode(true);
  const noteClone = assets.querySelector('.note').cloneNode(true);
  noteClone.id = Math.random();
  noteClone.classList.add(noteType);

  const plotSpace = staffClone.querySelector(`.${pitchSpace}`)
  if (plotSpace == null) return;
  plotSpace.appendChild(noteClone);
  return staffClone;
}

function plotStaffBlock(existingStaffBlock, pitchSpace, noteType) {

  const noteClone = assets.querySelector('.note').cloneNode(true);
  noteClone.id = Math.random();
  noteClone.classList.add(noteType);

  const plotSpace = existingStaffBlock.querySelector(`.${pitchSpace}`);
  if (plotSpace == null) return;
  plotSpace.appendChild(noteClone);
  return existingStaffBlock;
}


/*
### # # ### ### ###  ##
#   # # #   # #  #  #
##  # # ##  # #  #   #
#   # # #   # #  #    #
###  #  ### # #  #  ##
*/

function fileHandler(event) {
  const reader = new FileReader();
  reader.onload = () => {
    const parser = new DOMParser();
    const xmlDoc = parser
      .parseFromString(reader.result,"text/xml");
    populateStaffFromMusicXML(xmlDoc);
  }
  console.log(event.target.files[0])
  reader.readAsText(event.target.files[0]);
}

function showMenu(e) {
  const clickedStaff = e.target.closest('.staff');
  clickedStaff.append(document.querySelector('.menu'));
}

function dragstartHandler(e){
  const note = e.target;
  e.dataTransfer.setData('text/plain', note.id);
  const dragImage = note.cloneNode(true);
  const dragImageContainer = document.createElement('div');
  dragImageContainer.appendChild(dragImage);
  dragImageContainer.style.position = 'absolute';
  dragImageContainer.style.top = '-9999px';
  document.body.appendChild(dragImageContainer);
  e.dataTransfer.setDragImage(dragImageContainer, 20, 99);
}

function dragHandler(e) {
  e.preventDefault();
  const dragzone = e.target.closest('div');
  if (e.type === 'dragover') {
    dragzone.style.backgroundColor = 'red';
    // messageArea.innerText = dragzone.id;
  } else if (e.type === 'dragleave') {
    dragzone.style.backgroundColor = '';
    // messageArea.innerText = '';
  }
}

function dropHandler(e){
  e.preventDefault();
  const dropzone = e.target.closest('div');
  if (dropzone == null) return;
  const noteId = e.dataTransfer.getData('text');
  const draggedNote = document.getElementById(noteId)
  const noteClone = draggedNote.cloneNode(true);
  noteClone.id = Math.random();
  dropzone.style.backgroundColor = '';
  dropzone.appendChild(noteClone);
  if (draggedNote.parentNode) {
    draggedNote.parentNode.removeChild(draggedNote);
  }
}

function detectPatternsFromSteps() {
  const patterns = new Set();
  const len = noteSteps.length;
  for (let l = 1; l <= len / 2; l++) {
    for (let i = 0; i <= len - 2 * l; i++) {
      const a = noteSteps.slice(i, i + l).join('');
      const b = noteSteps.slice(i + l, i + 2 * l).join('');
      if (a === b) patterns.add(a);
    }
  }

  detectedPatterns = {};
  patterns.forEach(p => {
    const seqLen = p.length;
    const indexes = [];
    for (let i = 0; i <= len - seqLen; i++) {
      if (noteSteps.slice(i, i + seqLen).join('') === p) indexes.push(i);
    }
    if (indexes.length > 1) detectedPatterns[p] = { length: seqLen, positions: indexes };
  });

  const select = document.getElementById('phraseSelect');
  if (select) {
    select.innerHTML = '<option value="">Select melody</option>';
    Object.keys(detectedPatterns).forEach(p => {
      const opt = document.createElement('option');
      opt.value = p;
      opt.textContent = p;
      select.appendChild(opt);
    });
  }
}

function highlightPhrase(p) {
  noteElements.forEach(n => n.classList.remove('phrase-highlight'));
  if (!p || !detectedPatterns[p]) return;
  const info = detectedPatterns[p];
  info.positions.forEach(pos => {
    for (let i = 0; i < info.length; i++) {
      const idx = pos + i;
      const el = noteElements[idx];
      if (el) el.classList.add('phrase-highlight');
    }
  });
}

function addStaffBlock(pitchSpace='e4',noteType='quarter') {
  const staffClone = assets.querySelector('.staff').cloneNode(true);
  const noteClone = assets.querySelector('.note').cloneNode(true);
  noteClone.id = Math.random();
  noteClone.classList.add(noteType);

  // console.log(pitchSpace)

  const plotSpace = staffClone.querySelector(`.${pitchSpace}`)
  if (plotSpace == null) return;
  plotSpace.appendChild(noteClone);
  document.querySelector('.sheet')
  .appendChild(staffClone);
}

// Settings modal logic
const settingsModal = document.getElementById('settingsModal');
const openSettings = document.getElementById('openSettings');
const closeSettings = document.getElementById('closeSettings');
const darkModeToggle = document.getElementById('toggleDarkMode');

if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
  document.documentElement.classList.add('dark-mode');
  document.body.classList.add('dark-mode');
  const icon = darkModeToggle.querySelector('i');
  if (icon) icon.classList.replace('fa-moon', 'fa-sun');
}

openSettings.addEventListener('click', () => {
  settingsModal.classList.add('open');
});
closeSettings.addEventListener('click', () => {
  settingsModal.classList.remove('open');
});
darkModeToggle.addEventListener('click', () => {
  document.documentElement.classList.toggle('dark-mode');
  document.body.classList.toggle('dark-mode');
  const icon = darkModeToggle.querySelector('i');
  if (icon) {
    icon.classList.toggle('fa-moon');
    icon.classList.toggle('fa-sun');
  }
});

const colorSettings = [
  { css: '--space-color', id: 'spaceColor' },
  { css: '--line-color',  id: 'lineColor'  },
  { css: '--note-color',  id: 'noteColor'  },
  { css: '--tie-color',   id: 'tieColor'   },
];

colorSettings.forEach(s => {
  const input = document.getElementById(s.id);
  input.value = getComputedStyle(document.documentElement).getPropertyValue(s.css).trim();
  input.addEventListener('input', () => {
    document.documentElement.style.setProperty(s.css, input.value);
  });
});

const numericSettings = [
  { css: '--staff-width', id: 'staffWidth', unit: 'em' },
  { css: '--space-height', id: 'spaceHeight', unit: 'em' },
  { css: '--line-height', id: 'lineHeight', unit: 'em' },
  { css: '--note-height', id: 'noteHeight', unit: 'em' },
  { css: '--note-width', id: 'noteWidth', unit: 'em' },
];

numericSettings.forEach(s => {
  const input = document.getElementById(s.id);
  const current = getComputedStyle(document.documentElement).getPropertyValue(s.css).trim();
  input.value = parseFloat(current);
  input.addEventListener('input', () => {
    document.documentElement.style.setProperty(s.css, input.value + s.unit);
    tieify();
  });
});

const phraseSelect = document.getElementById('phraseSelect');
if (phraseSelect) {
  phraseSelect.addEventListener('change', e => highlightPhrase(e.target.value));
}

// Recalculate ties whenever layout changes
window.addEventListener('resize', tieify);
</script>
</html>
