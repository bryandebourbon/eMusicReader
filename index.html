<!-- 
TODO:

ASSETS
dotted note
rest support
natural, sharps and flats
clefs
key signature support


MVP FUNCTIONALITY
fix pinch should zoom like cmd+
swipe auto scrolls to satisfying position
buttons for "next page"
save melodies/files somewhere
font editor make stems and notes as big as u want

STRETCH GOALS
play notes
lyrics on bottom
chords on top 
listening for notes and plotting them

-->

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<!-- <meta http-equiv="refresh" content="10"> -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
<meta name="theme-color" content="#000000">
<link rel="manifest" href="manifest.json">
<link rel="apple-touch-icon" href="icons/icon-192.png">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-title" content="eMusicReader">
<meta name="apple-mobile-web-app-status-bar-style" content="black">

<title>Music Note</title>
<!--
..######...######...######.
.##....##.##....##.##....##
.##.......##.......##......
.##........######...######.
.##.............##.......##
.##....##.##....##.##....##
..######...######...######.
###########################
-->
<style>
:root {
  --space-color: white;
  --line-color: black;
  --note-color: black;
  --tie-color: red;

  --staff-width: 1.6em;
  --space-height: 1em;
  --line-height: 0.16em;

  --note-height: 0.775em;
  --note-width: 1.033em;

  --stem-height: 2.33em;
  --stem-width: 0.1em;

  --flag-height: 0.83em;
  --flag-width: 0.3em;

  --tie-thickness:0;
  --dark-opacity: 1;
}

@media (prefers-color-scheme: dark) {

  :root {
    --space-color: black;
    --line-color: white;
    --note-color: white;
    --dark-opacity: 0.75;
  }

  body {
    background-color: black;
  }
  
}

.dark-mode {
  --space-color: black;
  --line-color: white;
  --note-color: white;
  --dark-opacity: 0.75;
}

body.dark-mode {
  background-color: black;
}
.dark-mode .sheet {
  opacity: var(--dark-opacity);
}
input[type="range"] {
  accent-color: var(--line-color);
}
html, body {
  display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
  margin: 0;
  padding: 0;
  height: 100%; 
  width: 100%;  
  overflow: hidden;
   -webkit-touch-callout: none;  /* iOS Safari */
  -webkit-user-select: none;    /* Safari */
  -khtml-user-select: none;     /* Konqueror HTML */
  -moz-user-select: none;       /* Old versions of Firefox */
  -ms-user-select: none;        /* IE/Edge */
  user-select: none;            /* Non-prefixed version, currently supported by Chrome, Opera and Firefox */
}

svg {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}
  .controls {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    display: flex;
    flex-wrap: wrap;
    gap: 4px;
    background-color: var(--space-color);
    padding: 4px;
    z-index: 10;
  }
  .controls button,
  .controls i,
  .controls select {
    color: var(--line-color);
  }
  .controls select {
    background-color: var(--space-color);
    border: 1px solid var(--line-color);
  }
  .tooltip {
  position: relative;
  border: none;
  background: none;
}

.tooltip::after {
  content: attr(data-tooltip);
  position: absolute;
  bottom: calc(-1 * var(--space-height) * 1.5);
  left: 50%;
  transform: translateX(-50%);
  padding: 2px 6px;
  background-color: var(--line-color);
  color: var(--space-color);
  white-space: nowrap;
  border-radius: 4px;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.2s ease-in-out;
  z-index: 100;
}

.tooltip:hover::after {
  opacity: 1;
}
#settingsModal.modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0,0,0,0.5);
  display: none;
  align-items: center;
  justify-content: center;
}
#settingsModal.modal.open {
  display: flex;
}
#settingsModal .modal-content {
  background-color: var(--space-color);
  padding: 20px;
  border: 1px solid var(--line-color);
  max-height: 90vh;
  overflow-y: auto;
}
#settingsModal .modal-content label {
  display: block;
  margin: 5px 0;
}
#xmlInput {
  position: static;
}

#scoreInfo {
  margin-top: 40px;
  color: var(--line-color);
  display: none;
}
  
.sheet {
  padding: 40px;
  position:relative;
  display: flex;
    flex-wrap: wrap;
    overflow-y: auto;
}
.measure {
  position: relative;
  display: flex;
    flex-wrap: wrap;
    overflow: hidden;
  flex-grow:1;
}
.beam {
  position:relative;
  display: flex;
    flex-wrap: wrap;
    overflow: hidden;
  z-index: 4;
}
.staff {
  flex-grow:1;
  position: relative;
  display: flex;
    flex-direction: column;
    justify-content: space-between;
  min-width: var(--staff-width);
  /* margin-bottom: var(--space-height); */
  z-index: 0;
  margin:0;
}
.staff.selected {
  outline: 2px solid blue;
}

.line {
  background-color: var(--line-color);
  height: var(--line-height);
  position: relative;
  display: flex;
    justify-content: center;
}
.line > .note {
  position: absolute;
  top: calc(var(--space-height)* -0.3);
}

.space {
  height: var(--space-height);
  position: relative;
  display: flex;
    justify-content: center;
}
.space > .note {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
}
.stem-down {
  rotate: 180deg !important;
}

.stem-up {
  rotate: 0deg !important;
}

.high > .note {
  rotate: 180deg;
}
.high > .line {
  top: 0
}
.high.space > .note {
  top:  calc(var(--space-height) * 0.1);
  transform: translateY(0);
}

.ledger {
  background-color: var(--space-color);
}
.ledger:has(div){
  background-color: var(--line-color);
  /* height: 0.1em; */
}

/* <!--
###  #  ### ###  ##
# # # #  #  #   #
# # # #  #  ##   #
# # # #  #  #     #
# #  #   #  ### ##
--> */
.note {
  position: relative;
  width: var(--note-width);
  height: var(--note-height);
  z-index: 2;
}
.note > .head {
  position: absolute;
  width: var(--note-width);
  height: var(--note-height);
  rotate: -27deg;
  background-color: var(--note-color);
  border-radius: 50%;
}
.note.whole > .head {
  position: absolute;
  width: var(--note-width);
  height: var(--note-height);
  background-color: var(--note-color);
  border-radius: 50%;
  rotate: 0deg;
}

.note.half > .head::after {
  content: "";
  position: absolute;
  width: 80%;
  height: 50%;
  border-radius: 50%;
  background-color: var(--space-color);
  z-index: 2;
  top: calc(var(--space-height) * 0.2);
  left: calc(var(--space-height) * 0.1);
}
.note.whole > .head::after {
  content: "";
  position: absolute;
  width: 60%;
  height: 50%;
  border-radius: 50%;
  background-color: var(--space-color);
  z-index: 2;
  top: 25%;
  left: 21%;
  rotate: 40deg;
}
.line > .note.whole ::before {
  content: "";
  background-color: var(--line-color);
  height: var(--line-height);
  position: absolute;
  width: 100%;
  top: calc(var(--space-height) * 0.3);
  rotate: 0deg;
  z-index: 3;
}

.line > .note.half ::before {
  content: "";
  background-color: var(--line-color);
  height: var(--line-height);
  position: absolute;
  width: 100%;
  top: calc(var(--space-height) * 0.3);
  rotate: 27deg;
  z-index: 3;
}

/* <!--
 ## ### ### # #
#    #  #   ###
 #   #  ##  ###
  #  #  #   # #
##   #  ### # #
--> */
.stem {
  position: absolute;
  right: 3%;
  top: calc(var(--space-height) * -2);;
  width: var(--stem-width);
  height: var(--stem-height);
  background-color: var(--note-color);
  z-index: 1;
}
.note.whole > .stem {
  display:none;
}

/* <!--
### #    #   ##
#   #   # # #
##  #   ### # #
#   #   # # # #
#   ### # #  ##
--> */
.flag {
  display:none;
}
.note.sixteenth,
.note.eighth > .flag {
  display:block;
  background-color: var(--note-color);
  position: absolute;
  right: calc(var(--space-height) * -0.233);
  bottom: calc(var(--space-height) * 1.93);
  width: var(--flag-width);
  height: var(--flag-height);
  border-top-right-radius: calc(var(--space-height) * 0.5);
  border-bottom-right-radius:calc(var(--space-height) *  0.5);
}






.measure-bar {
  display: flex;
  flex-direction: column;
}
.measure-bar > div {
  display: block;
  width: calc(var(--space-height) * 0.3);
  height: calc(var(--space-height) * 4.83);
  background-color: var(--line-color);
  margin-top: calc(var(--space-height) * 1.1667);
  margin-bottom: calc(var(--space-height) * 1);
  position: relative;
}

.lineContainer {
  position: absolute;
  pointer-events: none;
  top: 0;
  left: 0;
}

.note.phrase-highlight {
  outline: 2px solid red;
}

.phrase-box {
  position: absolute;
  pointer-events: none;
  border: 2px dashed blue;
}
.phrase-box.winner {
  border: 4px solid green;
}

/* .tie-under {
    border-color: green blue red yellow;
    border-radius: 50px 50px 50px 50px;
} */

</style>
</head>
<!--
.##.....##.########.##.....##.##......
.##.....##....##....###...###.##......
.##.....##....##....####.####.##......
.#########....##....##.###.##.##......
.##.....##....##....##.....##.##......
.##.....##....##....##.....##.##......
.##.....##....##....##.....##.########
######################################
-->
<body onload="init();" style="touch-action:pan-y" >
<div class="controls">
  <input
    id="xmlInput"
    type="file"
    onchange="fileHandler(event)"/>

  <button id="useDefaultFile" class="tooltip" data-tooltip="Use Default File"><i class="fa-solid fa-file-lines"></i></button>
  <button onclick="addStaffBlock()" class="tooltip" data-tooltip="Add Staff"><i class="fa-solid fa-plus"></i></button>
  <button id="zoomIn" class="tooltip" data-tooltip="Zoom In"><i class="fa-solid fa-magnifying-glass-plus"></i></button>
  <button id="zoomOut" class="tooltip" data-tooltip="Zoom Out"><i class="fa-solid fa-magnifying-glass-minus"></i></button>
  <button id="refreshTies" class="tooltip" data-tooltip="Refresh Ties"><i class="fa-solid fa-arrows-rotate"></i></button>
  <button id="renderBeams" class="tooltip" data-tooltip="Render Beams"><i class="fa-solid fa-bars-staggered"></i></button>
  <button id="openSettings" class="tooltip" data-tooltip="Settings"><i class="fa-solid fa-gear"></i></button>
  <button id="toggleDarkMode" class="tooltip" data-tooltip="Toggle dark mode"><i class="fa-solid fa-moon"></i></button>
  <label class="tooltip" data-tooltip="Note opacity (dark mode)">
    <input type="range" id="darkOpacity" min="60" max="100" value="75">
  </label>
  <button id="toggleScoreInfo" class="tooltip" data-tooltip="Score Info"><i class="fa-solid fa-circle-info"></i></button>
  <button id="prevPage" class="tooltip" data-tooltip="Previous Page"><i class="fa-solid fa-arrow-left"></i></button>
  <button id="nextPage" class="tooltip" data-tooltip="Next Page"><i class="fa-solid fa-arrow-right"></i></button>
  <button id="runDetect" title="Run Detect Again">Detect</button>
  <select id="phraseSelect" title="Detected Melodies"></select>
  <label class="tooltip" data-tooltip="Toggle Automatic Labels/Ties">
    <input type="checkbox" id="autoFeatures"> Auto Ties
  </label>

</div>
<div id="scoreInfo"></div>

<div class="sheet" id="zoomContainer"></div>

<!-- Settings Modal -->
<div id="settingsModal" class="modal">
  <div class="modal-content">
    <button id="closeSettings" class="tooltip" data-tooltip="Close"><i class="fa-solid fa-xmark"></i></button>
    <h3>Settings</h3>
    <label>Space Color <input type="color" id="spaceColor"></label>
    <label>Line Color <input type="color" id="lineColor"></label>
    <label>Note Color <input type="color" id="noteColor"></label>
    <label>Tie Color <input type="color" id="tieColor"></label>
    <label>Staff Width <input type="range" id="staffWidth" min="0.5" max="3" step="0.1"></label>
    <label>Space Height <input type="range" id="spaceHeight" min="0.5" max="2" step="0.1"></label>
    <label>Line Height <input type="range" id="lineHeight" min="0.05" max="0.5" step="0.01"></label>
    <label>Note Height <input type="range" id="noteHeight" min="0.5" max="2" step="0.1"></label>
    <label>Note Width <input type="range" id="noteWidth" min="0.5" max="2" step="0.1"></label>
  </div>
</div>

<section class="assets"style="display:none;">

<div class="measure">
  <div class="measure-bar">
    <div></div>
    <div></div>
  </div>
</div>
<div class="staff" 
  ondrop="dropHandler(event)" 
  ondragover="dragHandler(event)" 
  ondragleave="dragHandler(event)" >
    <div class="line  a5 high ledger"></div>
    <div class="space g5 high"></div>
    <div class="line  f5 high"></div>
    <div class="space e5 high"></div>
    <div class="line  d5 high"></div>
    <div class="space c5 high"></div>
    <div class="line  b4 high"></div>
    <div class="space a4"></div>
    <div class="line  g4"></div>
    <div class="space f4"></div>
    <div class="line  e4"></div>
    <div class="space d4"></div>
    <div class="line  c4 ledger"></div>
    <div class="space b3 high"></div>
    <div class="line  a3 high"></div>
    <div class="space g3 high"></div>
    <div class="line  f3 high"></div>
    <div class="space e3 high"></div>
    <div class="line  d3 high"></div>
    <div class="space c3"></div>
    <div class="line  b2"></div>
    <div class="space a2"></div>
    <div class="line  g2"></div>
    <div class="space f2"></div>
    <div class="line  e2 ledger"></div>
</div>
<div class="note"
  ondragstart="dragstartHandler(event)"
  ondblclick="showMenu(event)"
  draggable="true">
    <div class="head"></div>
    <div class="stem"></div>
    <div class="flag"></div>
</div> 
<div class="beam"></div>

<svg class="lineContainer"></svg>

<!-- <div class="menu"
  onclick="">
    <div class="option">Sharp</div>
    <div class="option">Flat</div>
    <div class="option">Whole</div>
    <div class="option">Half</div>
    <div class="option">Quarter</div>
    <div class="option">Eighth</div>
    <div class="option">Sixteenth</div>
    <div class="option">Delete</div>
</div> -->
</section>
</body>
<script>
// Global vars to cache event state
let evCache = [];
let prevDiff = -1;

// Global arrays for melody pattern detection
let noteSteps = [];
let notePitches = [];
let pitchSigns = [];
const pitchMap = {c:0, d:1, e:2, f:3, g:4, a:5, b:6};
let noteElements = [];
let detectedPatterns = {};

let detectedDescending = {};
let phraseBoxes = [];

let allDetectedPatterns = {};
let winningGroups = [];

let autoFeaturesEnabled = false;


function init() {
// Install event handlers for the pointer target
  const el = document.getElementById("zoomContainer");
  el.onpointerdown = pointerdownHandler;
  el.onpointermove = pointermoveHandler;
  el.onpointerup = pointerupHandler;
  el.onpointercancel = pointerupHandler;
  el.onpointerout = pointerupHandler;
  el.onpointerleave = pointerupHandler;
}
function pointerdownHandler(ev) {
  evCache.push(ev);
  console.log("pointerDown", ev);
  console.log(evCache)
}

function pointermoveHandler(ev) {

  console.log("pointerMove", ev);

  // If two pointers are down, check for pinch gestures
  if (evCache.length === 2) {
    // Calculate the distance between the two pointers
    const curDiff = Math.abs(evCache[0].clientX - evCache[1].clientX);
console.log(curDiff)
console.log(prevDiff)
    if (prevDiff > 0) {
      if (curDiff > 70) {
        // The distance between the two pointers has increased
        console.log("Pinch moving OUT -> Zoom in", ev);
          zoomLevel += 0.1;
        zoomContainer.style.zoom = zoomLevel;
        if (autoFeaturesEnabled) tieify();
      }
      if (curDiff < prevDiff) {
        // The distance between the two pointers has decreased
        console.log("Pinch moving IN -> Zoom out", ev);
          zoomLevel -= 0.1;
  zoomContainer.style.zoom = zoomLevel;
  if (autoFeaturesEnabled) tieify();
      }
    } 
      prevDiff = curDiff;
    

    // Cache the distance for the next move event
    
  }
}
  
function pointerupHandler(ev) {
  prevDiff = -1;
  evCache = []
  console.log(evCache)
}




  
const assets = document.querySelector('.assets')

const zoomContainer = document.getElementById('zoomContainer');
let zoomLevel = 1;

document.getElementById('zoomIn').addEventListener('click', () => {
  zoomLevel += 0.1;
  zoomContainer.style.zoom = zoomLevel;
  if (autoFeaturesEnabled) tieify();
});

document.getElementById('zoomOut').addEventListener('click', () => {
  zoomLevel -= 0.1;
  zoomContainer.style.zoom = zoomLevel;
  if (autoFeaturesEnabled) tieify();

});

document.getElementById('refreshTies').addEventListener('click', () => {
  tieify();
});

document.getElementById('renderBeams').addEventListener('click', () => {
  requestAnimationFrame(() => {
    beamify();
    if (autoFeaturesEnabled) tieify();
  });
});

document.getElementById('useDefaultFile').addEventListener('click', function() {
  fetch('ddd.xml') // Adjust the path if your XML file is in a specific directory
    .then(response => response.text())
    .then(data => {
      const parser = new DOMParser();
      const xmlDoc = parser.parseFromString(data,"text/xml");
      displayScoreInfo(parseScoreInfo(xmlDoc));
      populateStaffFromMusicXML(xmlDoc);
    })
    .catch(error => console.error('Error loading the default file:', error));
});

 
/*

##  ###  #  # #  ##
# # #   # # ### #
##  ##  ### ###  #
# # #   # # # #   #
##  ### # # # # ##

*/

function drawLine(flag1, flagn, parent, isDown ) {
  if (flag1 === undefined) return;
  const rect1=flag1.getBoundingClientRect();
  const rect2=flagn.getBoundingClientRect();
  const parentRect = parent.getBoundingClientRect();

  const svg = document.querySelector('.assets .lineContainer').cloneNode(true);
  svg.id = Math.random();

  const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');

  
 const lineColor = getComputedStyle(document.documentElement).getPropertyValue('--line-color').trim();;
  
  if (!isDown) {
    line.setAttribute('x1', (rect1.left) - parentRect.left);
    line.setAttribute('y1', (rect1.top) - parentRect.top);
    line.setAttribute('x2', (rect2.left) - parentRect.left);
    line.setAttribute('y2', (rect2.top ) - parentRect.top);
    
    line.setAttribute('stroke', lineColor);
    line.setAttribute('stroke-width', '10');
  } else {
    line.setAttribute('x1', (rect1.right) - parentRect.left);
    line.setAttribute('y1', (rect1.bottom) - parentRect.top);
    line.setAttribute('x2', (rect2.right) - parentRect.left);
    line.setAttribute('y2', (rect2.bottom ) - parentRect.top);
    
    line.setAttribute('stroke', lineColor);
    line.setAttribute('stroke-width', '20');
  }
  
  svg.appendChild(line);
  parent.appendChild(svg);

  return line;
}
  
function tieify() {
  // Clear existing ties
  const existingTies = document.querySelectorAll('.sheet .tieDiv');
  existingTies.forEach(tie => tie.remove());

  const notes = document.querySelectorAll('.sheet .note');
  const tiePairs = {};

  notes.forEach(note => {
    Array.from(note.attributes).forEach(attr => {
      if (attr.name.startsWith('data-tie')) {
        const number = attr.name.replace('data-tie', '');
        const type = attr.value;
        if (!tiePairs[number]) tiePairs[number] = { start: [], stop: [] };
        tiePairs[number][type].push(note);
      }
    });
  });

  Object.values(tiePairs).forEach(pair => {
    const count = Math.min(pair.start.length, pair.stop.length);
    for (let i = 0; i < count; i++) {
      const startNote = pair.start[i];
      const stopNote = pair.stop[i];
      const start = startNote.getBoundingClientRect();
      const stop = stopNote.getBoundingClientRect();

      const tieDiv = document.createElement('div');
      tieDiv.className = 'tieDiv'; // Add a class name for easy removal later
      tieDiv.style.position = 'absolute';
      tieDiv.style.height = '2em';

      tieDiv.style.borderStyle = 'solid';
      tieDiv.style.borderWidth = '0.5em';

      const orientation = startNote.classList.contains('tie-under') ? 'under' : 'over';
      if (orientation === 'under') {
        tieDiv.style.borderColor = 'red transparent transparent transparent';
        tieDiv.style.borderRadius = '100px 100px 0px 0px';
        tieDiv.style.top = `${start.bottom + window.scrollY - 10}px`;
      } else {
        tieDiv.style.borderColor = 'transparent transparent red transparent';
        tieDiv.style.borderRadius = '0px 0px 100px 100px';
        tieDiv.style.top = `${start.top + window.scrollY - 30}px`;
      }
      tieDiv.style.left = `${start.left + window.scrollX}px`;

      tieDiv.style.width = `${stop.left - start.left}px`;

      document.querySelector('.sheet').appendChild(tieDiv);
    }
  });
}



function beamify() {
  const beamElements = document.querySelectorAll('.beam');
  const stemXCoords = []; 

  beamElements.forEach(beamGroup => {
    const notes=beamGroup.querySelectorAll('.note');
    const flags=beamGroup.querySelectorAll('.flag');
    const stems=beamGroup.querySelectorAll('.stem');

    const beamRect = beamGroup.getBoundingClientRect();

    const firstFlag = flags[0];
    const lastFlag = flags[flags.length - 1];

    let svg;

    let containsDown = false;
    notes.forEach(note => {
      if (note.classList.contains("stem-down")) {
        containsDown = true;
      }
    });

    if (firstFlag && lastFlag) {
      svg = drawLine(firstFlag, lastFlag, beamGroup, containsDown);
    }

    // Remove flags
    flags.forEach(flag => {
      flag.remove();
    });

    const line = beamGroup.querySelector('line');
    if (line == null) return;
    // console.log(line);
    const lineY1 = parseFloat(line.getAttribute('y1'));
    const lineY2 = parseFloat(line.getAttribute('y2'));
    const lineX1 = parseFloat(line.getAttribute('x1'));
    const lineX2 = parseFloat(line.getAttribute('x2'));

    const lineSlope = (lineY2 - lineY1) / (lineX2 - lineX1);

    notes.forEach(note => {
      const stems = note.querySelector('.stem');
      const rect = stems.getBoundingClientRect();
      const xCoord = rect.left - beamRect.left;
      stemXCoords.push(xCoord);

      const lineYAtX = lineY1 + lineSlope * (xCoord - lineX1);

      const difference = (rect.bottom - beamRect.top) - lineYAtX;

      if (difference < 0) {
        const newLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        newLine.setAttribute('x1', xCoord);
        newLine.setAttribute('y1', rect.bottom - beamRect.top);
        newLine.setAttribute('x2', xCoord);
        newLine.setAttribute('y2', lineYAtX);
        newLine.setAttribute('stroke', 'red');
        newLine.setAttribute('stroke-width', '20');
        beamGroup.querySelector('svg').appendChild(newLine);
      }
    });

  });
}

// # # # #  ## ###  ##     # # # # #
// ### # # #    #  #       # # ### #
// ### # #  #   #  #   ###  #  ### #
// # # # #   #  #  #       # # # # #
// # # ### ##  ###  ##     # # # # ###
function appendMeasureNotes(measure, measureDiv) {
  let beamDiv = null;
  let prevStaffBlock = null;
  const notes = measure.getElementsByTagName("note");
  for (let j = 0; j < notes.length; j++) {
    const isChord = notes[j].getElementsByTagName("chord")[0];
    const stepElement = notes[j].getElementsByTagName("step")[0];
    const octaveElement = notes[j].getElementsByTagName("octave")[0];
    const typeElement = notes[j].getElementsByTagName("type")[0];
    const stemElement = notes[j].getElementsByTagName("stem")[0];
    const beamElement = notes[j].getElementsByTagName("beam")[0];
    const tiedElements = notes[j].getElementsByTagName("tied");

    if (stepElement && octaveElement && typeElement) {
      const step = stepElement.textContent.toLowerCase();
      const octave = octaveElement.textContent;
      const noteType = typeElement.textContent;
      const musicNote = `${step}${octave}`;

      let staffBlock;
      if (isChord) {
        staffBlock = plotStaffBlock(prevStaffBlock, musicNote, noteType);
      } else {
        staffBlock = genStaffBlock(musicNote, noteType);
      }

      if (staffBlock instanceof Node) {
        const noteDiv = staffBlock.querySelector('.note');
        if (stemElement) {
          const stemDirection = stemElement.textContent;
          if (noteDiv) {
            noteDiv.classList.add(`stem-${stemDirection}`);
          }
        }

        if (tiedElements && tiedElements.length) {
          for (let t = 0; t < tiedElements.length; t++) {
            const tie = tiedElements[t];
            const number = tie.getAttribute('number') || '1';
            const orientation = tie.getAttribute('orientation');
            const type = tie.getAttribute('type');

            noteDiv.dataset[`tie${number}`] = type;
            if (orientation) {
              noteDiv.classList.add(`tie-${orientation}`);
            }
          }
        }

        if (beamElement) {
          const beamType = beamElement.textContent;
          if (beamType === "begin") {
            beamDiv = document.querySelector('.assets .beam').cloneNode(true);
          }
          if (beamDiv && beamDiv instanceof Node) {
            beamDiv.appendChild(staffBlock);
          }
          if (beamType === "end" && beamDiv) {
            measureDiv.appendChild(beamDiv);
            beamDiv = null;
          }
        } else {
          if (beamDiv && beamDiv instanceof Node) {
            measureDiv.appendChild(beamDiv);
            beamDiv = null;
          }
          if (!isChord) {
            measureDiv.appendChild(staffBlock);
          }
        }
        if (!isChord) {
          prevStaffBlock = staffBlock;
        }
      }
    }
  }
  return measureDiv;
}

function parseMeasureNotes(measure) {
  const result = [];
  let currentTime = 0;

  Array.from(measure.children).forEach(el => {
    if (el.tagName === 'note') {
      const durationEl = el.getElementsByTagName('duration')[0];
      const duration = durationEl ? parseInt(durationEl.textContent) : 0;

      const stepEl = el.getElementsByTagName('step')[0];
      const octaveEl = el.getElementsByTagName('octave')[0];
      const typeEl = el.getElementsByTagName('type')[0];
      const stemEl = el.getElementsByTagName('stem')[0];
      const beamEl = el.getElementsByTagName('beam')[0];
      const tiedEls = el.getElementsByTagName('tied');
      const isChord = el.getElementsByTagName('chord')[0];

      if (stepEl && octaveEl && typeEl) {
        const ties = [];
        if (tiedEls && tiedEls.length) {
          for (let t = 0; t < tiedEls.length; t++) {
            ties.push({
              number: tiedEls[t].getAttribute('number') || '1',
              orientation: tiedEls[t].getAttribute('orientation'),
              type: tiedEls[t].getAttribute('type')
            });
          }
        }

        result.push({
          time: currentTime,
          step: stepEl.textContent.toLowerCase(),
          octave: octaveEl.textContent,
          noteType: typeEl.textContent,
          isChord: !!isChord,
          stem: stemEl ? stemEl.textContent : null,
          beam: beamEl ? beamEl.textContent : null,
          ties
        });
      }

      if (!isChord) {
        currentTime += duration;
      }
    } else if (el.tagName === 'forward') {
      const dur = el.getElementsByTagName('duration')[0];
      if (dur) currentTime += parseInt(dur.textContent);
    } else if (el.tagName === 'backup') {
      const dur = el.getElementsByTagName('duration')[0];
      if (dur) currentTime -= parseInt(dur.textContent);
    }
  });

  return result;
}

function parseScoreInfo(xmlDoc) {
  const info = { dynamics: [], textDirections: [] };
  const attr = xmlDoc.querySelector('part measure attributes');
  if (attr) {
    const fifths = attr.querySelector('key fifths');
    if (fifths) info.key = fifths.textContent;
    const beats = attr.querySelector('time beats');
    const beatType = attr.querySelector('time beat-type');
    if (beats && beatType) info.time = `${beats.textContent}/${beatType.textContent}`;
    const clef = attr.querySelector('clef sign');
    if (clef) info.clef = clef.textContent;
  }
  xmlDoc.querySelectorAll('direction-type dynamics').forEach(d => {
    const child = d.firstElementChild;
    if (child) info.dynamics.push(child.tagName);
  });
  xmlDoc.querySelectorAll('direction-type words').forEach(w => {
    info.textDirections.push(w.textContent.trim());
  });
  return info;
}

function displayScoreInfo(info) {
  const div = document.getElementById('scoreInfo');
  if (!div) return;
  div.innerHTML = '';
  if (info.key) div.innerHTML += `<div>Key: ${info.key}</div>`;
  if (info.time) div.innerHTML += `<div>Time: ${info.time}</div>`;
  if (info.clef) div.innerHTML += `<div>Clef: ${info.clef}</div>`;
  if (info.dynamics.length) div.innerHTML += `<div>Dynamics: ${info.dynamics.join(', ')}</div>`;
  if (info.textDirections.length) div.innerHTML += `<div>Directions: ${info.textDirections.join(', ')}</div>`;
}

function appendInterleavedNotes(notesByPart, measureDiv) {
  const beamDivs = new Array(notesByPart.length).fill(null);
  const prevBlocks = new Array(notesByPart.length).fill(null);

  const allNotes = [];
  notesByPart.forEach((notes, idx) => {
    notes.forEach(n => allNotes.push(Object.assign({ part: idx }, n)));
  });

  allNotes.sort((a, b) => {
    if (a.time === b.time) return a.part - b.part;
    return a.time - b.time;
  });

  allNotes.forEach(n => {
    const part = n.part;
    let beamDiv = beamDivs[part];
    let prevStaffBlock = prevBlocks[part];

    const musicNote = `${n.step}${n.octave}`;
    let staffBlock;
    if (n.isChord) {
      staffBlock = plotStaffBlock(prevStaffBlock, musicNote, n.noteType);
    } else {
      staffBlock = genStaffBlock(musicNote, n.noteType);
    }

    if (staffBlock instanceof Node) {
      const noteDiv = staffBlock.querySelector('.note');
      if (n.stem && noteDiv) {
        noteDiv.classList.add(`stem-${n.stem}`);
      }

      if (noteDiv) {
        noteDiv.dataset.index = noteSteps.length;
        noteSteps.push(n.step);
        const pitchVal = pitchMap[n.step] + parseInt(n.octave) * 7;
        notePitches.push(pitchVal);
        if (notePitches.length > 1) {
          const diff = pitchVal - notePitches[notePitches.length-2];
          pitchSigns.push(diff > 0 ? 'U' : diff < 0 ? 'D' : 'S');
        }
        noteElements.push(noteDiv);
      }

      if (n.ties && n.ties.length) {
        n.ties.forEach(tie => {
          noteDiv.dataset[`tie${tie.number}`] = tie.type;
          if (tie.orientation) {
            noteDiv.classList.add(`tie-${tie.orientation}`);
          }
        });
      }

      if (n.beam) {
        if (n.beam === 'begin') {
          beamDiv = document.querySelector('.assets .beam').cloneNode(true);
        }
        if (beamDiv && beamDiv instanceof Node) {
          beamDiv.appendChild(staffBlock);
        }
        if (n.beam === 'end' && beamDiv) {
          measureDiv.appendChild(beamDiv);
          beamDiv = null;
        }
      } else {
        if (beamDiv && beamDiv instanceof Node) {
          measureDiv.appendChild(beamDiv);
          beamDiv = null;
        }
        if (!n.isChord) {
          measureDiv.appendChild(staffBlock);
        }
      }

      if (!n.isChord) {
        prevStaffBlock = staffBlock;
      }
    }

    beamDivs[part] = beamDiv;
    prevBlocks[part] = prevStaffBlock;
  });

  beamDivs.forEach(beamDiv => {
    if (beamDiv && beamDiv instanceof Node) {
      measureDiv.appendChild(beamDiv);
    }
  });

  return measureDiv;
}

function populateStaffFromMusicXML(xmlDoc) {
  noteSteps = [];
  notePitches = [];
  pitchSigns = [];
  noteElements = [];
  detectedPatterns = {};
  detectedDescending = {};
  clearPhraseBoxes();

  displayScoreInfo(parseScoreInfo(xmlDoc));

  const parts = xmlDoc.getElementsByTagName("part");
  const sheet = document.querySelector('.sheet');
  sheet.innerHTML = '';

  const measuresByPart = Array.from(parts).map(p => p.getElementsByTagName("measure"));
  const maxMeasures = Math.max(...measuresByPart.map(m => m.length));

  const parsed = measuresByPart.map(measures => Array.from(measures).map(m => parseMeasureNotes(m)));

  for (let i = 0; i < maxMeasures; i++) {
    let measureDiv = document.querySelector('.assets .measure').cloneNode(true);

    const notesForMeasure = parsed.map(p => p[i] || []);
    measureDiv = appendInterleavedNotes(notesForMeasure, measureDiv);

    sheet.appendChild(measureDiv);
  }
  // Ensure layout is calculated before drawing beams and ties

  requestAnimationFrame(() => {
      detectPatternsFromSteps();
      detectDescendingPatterns();
      updateAllPatterns();
      findWinningPatterns();
      showWinningBoxes();
      updatePhraseSelect();
      if (autoFeaturesEnabled) {
        tieify();
        beamify();
      }
  });
}


//  ## ###  #  ### ### ##  #    #   ## # #
// #    #  # # #   #   # # #   # # #   # #
//  #   #  ### ##  ##  ##  #   # # #   ##
//   #  #  # # #   #   # # #   # # #   # #
// ##   #  # # #   #   ##  ###  #   ## # #

function genStaffBlock(pitchSpace='e4', noteType='quarter') {
  const staffClone = assets.querySelector('.staff').cloneNode(true);
  const noteClone = assets.querySelector('.note').cloneNode(true);
  noteClone.id = Math.random();
  noteClone.classList.add(noteType);

  const stepLetter = pitchSpace.replace(/\d+/, "");
  staffClone.dataset.letters = stepLetter;
  const plotSpace = staffClone.querySelector(`.${pitchSpace}`)
  if (plotSpace == null) return;
  plotSpace.appendChild(noteClone);
  return staffClone;
}

function plotStaffBlock(existingStaffBlock, pitchSpace, noteType) {

  const noteClone = assets.querySelector('.note').cloneNode(true);
  noteClone.id = Math.random();
  noteClone.classList.add(noteType);

  const stepLetter = pitchSpace.replace(/\d+/, "");
  existingStaffBlock.dataset.letters = existingStaffBlock.dataset.letters
    ? existingStaffBlock.dataset.letters + " " + stepLetter
    : stepLetter;
  const plotSpace = existingStaffBlock.querySelector(`.${pitchSpace}`);
  if (plotSpace == null) return;
  plotSpace.appendChild(noteClone);
  return existingStaffBlock;
}


/*
### # # ### ### ###  ##
#   # # #   # #  #  #
##  # # ##  # #  #   #
#   # # #   # #  #    #
###  #  ### # #  #  ##
*/

function fileHandler(event) {
  const reader = new FileReader();
  reader.onload = () => {
    const parser = new DOMParser();
    const xmlDoc = parser
      .parseFromString(reader.result,"text/xml");
    displayScoreInfo(parseScoreInfo(xmlDoc));
    populateStaffFromMusicXML(xmlDoc);
    if (autoFeaturesEnabled) requestAnimationFrame(tieify);
  }
  console.log(event.target.files[0])
  reader.readAsText(event.target.files[0]);
}

function showMenu(e) {
  const clickedStaff = e.target.closest('.staff');
  clickedStaff.append(document.querySelector('.menu'));
}

function dragstartHandler(e){
  const note = e.target;
  e.dataTransfer.setData('text/plain', note.id);
  const dragImage = note.cloneNode(true);
  const dragImageContainer = document.createElement('div');
  dragImageContainer.appendChild(dragImage);
  dragImageContainer.style.position = 'absolute';
  dragImageContainer.style.top = '-9999px';
  document.body.appendChild(dragImageContainer);
  e.dataTransfer.setDragImage(dragImageContainer, 20, 99);
}

function dragHandler(e) {
  e.preventDefault();
  const dragzone = e.target.closest('div');
  if (e.type === 'dragover') {
    dragzone.style.backgroundColor = 'red';
    // messageArea.innerText = dragzone.id;
  } else if (e.type === 'dragleave') {
    dragzone.style.backgroundColor = '';
    // messageArea.innerText = '';
  }
}

function dropHandler(e){
  e.preventDefault();
  const dropzone = e.target.closest('div');
  if (dropzone == null) return;
  const noteId = e.dataTransfer.getData('text');
  const draggedNote = document.getElementById(noteId)
  const noteClone = draggedNote.cloneNode(true);
  noteClone.id = Math.random();
  dropzone.style.backgroundColor = '';
  dropzone.appendChild(noteClone);
  if (draggedNote.parentNode) {
    draggedNote.parentNode.removeChild(draggedNote);
  }
}

function detectPatternsFromSteps() {
  console.log('detectPatternsFromSteps: start', noteSteps);
  const patterns = new Set();
  const len = noteSteps.length;
  for (let l = 4; l <= len / 2; l++) {
    for (let i = 0; i <= len - 2 * l; i++) {
      const a = noteSteps.slice(i, i + l).join('');
      const b = noteSteps.slice(i + l, i + 2 * l).join('');
      if (a === b) patterns.add(a);
    }
  }

  detectedPatterns = {};
  patterns.forEach(p => {
    const seqLen = p.length;
    const indexes = [];
    for (let i = 0; i <= len - seqLen; i++) {
      if (noteSteps.slice(i, i + seqLen).join('') === p) indexes.push(i);
    }
    if (indexes.length > 1) detectedPatterns[p] = { length: seqLen, positions: indexes };
  });

  // Remove patterns that are just one note shorter at either end of a longer pattern
  const keys = Object.keys(detectedPatterns).sort((a, b) => detectedPatterns[b].length - detectedPatterns[a].length);
  keys.forEach(long => {
    keys.forEach(short => {
      if (detectedPatterns[short] && detectedPatterns[long] && long.length === short.length + 1) {
        if (long.slice(1) === short || long.slice(0, -1) === short) {
          delete detectedPatterns[short];
        }
      }
    });
  });

  console.log('detectPatternsFromSteps: found', detectedPatterns);
}

function highlightPhrase(p) {
  console.log('highlightPhrase', p);
  noteElements.forEach(n => n.classList.remove('phrase-highlight'));
  clearPhraseBoxes();
  if (!p) return;
  const info = allDetectedPatterns[p] || detectedPatterns[p] || detectedDescending[p];
  if (!info) return;
  info.positions.forEach(pos => {
    for (let i = 0; i < info.length; i++) {
      const idx = pos + i;
      const el = noteElements[idx];
      if (el) el.classList.add('phrase-highlight');
    }
    drawPhraseBox(pos, pos + info.length - 1, true);
  });
}

function clearPhraseBoxes() {
  phraseBoxes.forEach(b => b.remove());
  phraseBoxes = [];
}

function drawPhraseBox(startIdx, endIdx, isWinner = false) {
  const sheet = document.querySelector('.sheet');
  const notes = noteElements.slice(startIdx, endIdx + 1);
  if (!notes.length) return;
  const rects = notes.map(n => n.getBoundingClientRect());
  const sheetRect = sheet.getBoundingClientRect();
  const left = Math.min(...rects.map(r => r.left)) - sheetRect.left + window.scrollX;
  const top = Math.min(...rects.map(r => r.top)) - sheetRect.top + window.scrollY;
  const right = Math.max(...rects.map(r => r.right)) - sheetRect.left + window.scrollX;
  const bottom = Math.max(...rects.map(r => r.bottom)) - sheetRect.top + window.scrollY;

  const box = document.createElement('div');
  box.className = isWinner ? 'phrase-box winner' : 'phrase-box';
  box.style.left = `${left}px`;
  box.style.top = `${top}px`;
  box.style.width = `${right - left}px`;
  box.style.height = `${bottom - top}px`;
  sheet.appendChild(box);
  phraseBoxes.push(box);
  return box;
}

function detectDescendingPatterns() {
  const len = notePitches.length;
  const patterns = {};
  for (let l = 3; l <= 10 && l <= len; l++) {
    for (let i = 0; i <= len - l; i++) {
      if (notePitches[i + l - 1] >= notePitches[i]) continue;
      const key = pitchSigns.slice(i, i + l - 1).join('');
      if (!patterns[key]) patterns[key] = { length: l, positions: [] };
      patterns[key].positions.push(i);
    }
  }
  Object.keys(patterns).forEach(k => {
    const info = patterns[k];
    info.positions.sort((a, b) => a - b);
    const pruned = [];
    info.positions.forEach(pos => {
      if (pruned.every(p => pos >= p + info.length)) pruned.push(pos);
    });
    if (pruned.length < 2) {
      delete patterns[k];
    } else {
      info.positions = pruned;
    }
  });
  detectedDescending = patterns;
}

function showDescendingBoxes() {
  clearPhraseBoxes();
  Object.values(detectedDescending).forEach(info => {
    if (!info || !info.positions) return;
    info.positions.forEach(pos => drawPhraseBox(pos, pos + info.length - 1));
  });
}

function updatePhraseSelect() {
  const select = document.getElementById('phraseSelect');
  if (!select) return;
  select.innerHTML = '<option value="">Select melody</option>';
  const merged = { ...detectedPatterns, ...detectedDescending };
  allDetectedPatterns = merged;
  Object.keys(merged).forEach(p => {
    const opt = document.createElement('option');
    opt.value = p;
    opt.textContent = p;
    select.appendChild(opt);
  });
}

function updateAllPatterns() {
  allDetectedPatterns = { ...detectedPatterns, ...detectedDescending };
}

function levenshtein(a, b) {
  const m = a.length, n = b.length;
  const dp = Array.from({ length: m + 1 }, () => new Array(n + 1).fill(0));
  for (let i = 0; i <= m; i++) dp[i][0] = i;
  for (let j = 0; j <= n; j++) dp[0][j] = j;
  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      if (a[i-1] === b[j-1]) dp[i][j] = dp[i-1][j-1];
      else dp[i][j] = Math.min(dp[i-1][j-1], dp[i][j-1], dp[i-1][j]) + 1;
    }
  }
  return dp[m][n];
}

function groupSimilarPhrases(patterns, threshold = 0.3) {
  const groups = [];
  Object.keys(patterns).forEach(p => {
    let placed = false;
    for (const g of groups) {
      const dist = levenshtein(p, g.rep);
      const limit = Math.min(p.length, g.rep.length) * threshold;
      if (dist <= limit) {
        g.patterns.push(p);
        placed = true;
        break;
      }
    }
    if (!placed) groups.push({ rep: p, patterns: [p] });
  });
  return groups;
}

function findWinningPatterns(maxLen = 20) {
  const groups = groupSimilarPhrases(allDetectedPatterns);
  winningGroups = [];
  groups.forEach(g => {
    let winner = null;
    g.patterns.forEach(p => {
      const len = allDetectedPatterns[p].length;
      if (len <= maxLen && (!winner || len > allDetectedPatterns[winner].length)) {
        winner = p;
      }
    });
    if (winner) winningGroups.push({ winner });
  });
}

function showWinningBoxes() {
  clearPhraseBoxes();
  winningGroups.forEach(g => {
    const info = allDetectedPatterns[g.winner];
    if (!info) return;
    info.positions.forEach(pos => drawPhraseBox(pos, pos + info.length - 1, true));
  });
}

function addStaffBlock(pitchSpace='e4',noteType='quarter') {
  const staffClone = assets.querySelector('.staff').cloneNode(true);
  const noteClone = assets.querySelector('.note').cloneNode(true);
  noteClone.id = Math.random();
  noteClone.classList.add(noteType);

  // console.log(pitchSpace)

  const stepLetter = pitchSpace.replace(/\d+/, "");
  staffClone.dataset.letters = stepLetter;
  const plotSpace = staffClone.querySelector(`.${pitchSpace}`)
  if (plotSpace == null) return;
  plotSpace.appendChild(noteClone);
  document.querySelector('.sheet')
  .appendChild(staffClone);
}

// Settings modal logic
const settingsModal = document.getElementById('settingsModal');
const openSettings = document.getElementById('openSettings');
const closeSettings = document.getElementById('closeSettings');
const darkModeToggle = document.getElementById('toggleDarkMode');

const toggleScoreInfoBtn = document.getElementById('toggleScoreInfo');

const autoFeatureToggle = document.getElementById('autoFeatures');
if (autoFeatureToggle) {
  autoFeaturesEnabled = autoFeatureToggle.checked;
}


if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
  document.documentElement.classList.add('dark-mode');
  document.body.classList.add('dark-mode');
  const icon = darkModeToggle.querySelector('i');
  if (icon) icon.classList.replace('fa-moon', 'fa-sun');
}

openSettings.addEventListener('click', () => {
  settingsModal.classList.add('open');
});
closeSettings.addEventListener('click', () => {
  settingsModal.classList.remove('open');
});
darkModeToggle.addEventListener('click', () => {
  document.documentElement.classList.toggle('dark-mode');
  document.body.classList.toggle('dark-mode');
  const icon = darkModeToggle.querySelector('i');
  if (icon) {
    icon.classList.toggle('fa-moon');
    icon.classList.toggle('fa-sun');
  }
});
if (toggleScoreInfoBtn) {
  toggleScoreInfoBtn.addEventListener('click', () => {
    const div = document.getElementById('scoreInfo');
    if (!div) return;
    div.style.display = div.style.display === 'none' ? '' : 'none';
  });
}

if (autoFeatureToggle) {
  autoFeatureToggle.addEventListener('change', () => {
    autoFeaturesEnabled = autoFeatureToggle.checked;
    if (autoFeaturesEnabled) {
      tieify();
      detectPatternsFromSteps();
    } else {
      document.querySelectorAll('.sheet .tieDiv').forEach(t => t.remove());
      highlightPhrase('');
    }
  });
}

const colorSettings = [
  { css: '--space-color', id: 'spaceColor' },
  { css: '--line-color',  id: 'lineColor'  },
  { css: '--note-color',  id: 'noteColor'  },
  { css: '--tie-color',   id: 'tieColor'   },
];

colorSettings.forEach(s => {
  const input = document.getElementById(s.id);
  input.value = getComputedStyle(document.documentElement).getPropertyValue(s.css).trim();
  input.addEventListener('input', () => {
    document.documentElement.style.setProperty(s.css, input.value);
  });
});

const numericSettings = [
  { css: '--staff-width', id: 'staffWidth', unit: 'em' },
  { css: '--space-height', id: 'spaceHeight', unit: 'em' },
  { css: '--line-height', id: 'lineHeight', unit: 'em' },
  { css: '--note-height', id: 'noteHeight', unit: 'em' },
  { css: '--note-width', id: 'noteWidth', unit: 'em' },
];

numericSettings.forEach(s => {
  const input = document.getElementById(s.id);
  const current = getComputedStyle(document.documentElement).getPropertyValue(s.css).trim();
  input.value = parseFloat(current);
  input.addEventListener('input', () => {
    document.documentElement.style.setProperty(s.css, input.value + s.unit);
    if (autoFeaturesEnabled) tieify();
  });
});

const darkOpacitySlider = document.getElementById('darkOpacity');
if (darkOpacitySlider) {
  function updateDarkOpacity() {
    const value = darkOpacitySlider.value / 100;
    document.documentElement.style.setProperty('--dark-opacity', value);
    document.body.style.setProperty('--dark-opacity', value);
  }
  darkOpacitySlider.addEventListener('input', updateDarkOpacity);
  updateDarkOpacity();
}
const sheetElement = document.querySelector(".sheet");
let selecting = false;
let startIndex = -1;
let staffList = [];
let startX = 0;
let startY = 0;

function clearSelection() {
  sheetElement.querySelectorAll(".staff.selected").forEach(el => el.classList.remove("selected"));
}

sheetElement.addEventListener("mousedown", e => {
  const block = e.target.closest(".staff");
  if (!block) return;
  staffList = Array.from(sheetElement.querySelectorAll(".staff"));
  startIndex = staffList.indexOf(block);
  if (startIndex === -1) return;
  selecting = true;
  clearSelection();
  block.classList.add("selected");
  e.preventDefault();
});

sheetElement.addEventListener("touchstart", e => {
  const touch = e.touches[0];
  const el = touch ? document.elementFromPoint(touch.clientX, touch.clientY) : e.target;
  const block = el && el.closest(".staff");
  if (!block) return;
  startX = touch.clientX;
  startY = touch.clientY;
  staffList = Array.from(sheetElement.querySelectorAll(".staff"));
  startIndex = staffList.indexOf(block);
  if (startIndex === -1) return;
  selecting = true;
  clearSelection();
  block.classList.add("selected");
});

sheetElement.addEventListener("mousemove", e => {
  if (!selecting) return;
  const block = e.target.closest(".staff");
  if (!block) return;
  const idx = staffList.indexOf(block);
  if (idx === -1) return;
  clearSelection();
  const [start, end] = idx >= startIndex ? [startIndex, idx] : [idx, startIndex];
  for (let i = start; i <= end; i++) {
    staffList[i].classList.add("selected");
  }
});

sheetElement.addEventListener("touchmove", e => {
  if (!selecting) return;
  const touch = e.touches[0];
  const dx = Math.abs(touch.clientX - startX);
  const dy = Math.abs(touch.clientY - startY);
  if (dy > dx) {
    selecting = false;
    clearSelection();
    return; // allow scrolling
  }
  const el = document.elementFromPoint(touch.clientX, touch.clientY);
  const block = el && el.closest(".staff");
  if (!block) return;
  const idx = staffList.indexOf(block);
  if (idx === -1) return;
  clearSelection();
  const [start, end] = idx >= startIndex ? [startIndex, idx] : [idx, startIndex];
  for (let i = start; i <= end; i++) {
    staffList[i].classList.add("selected");
  }
  e.preventDefault();
});

function highlightExactFromSelection() {
  const selected = sheetElement.querySelectorAll('.staff.selected');
  if (!selected.length) return;
  const firstNotes = selected[0].querySelectorAll('.note');
  const lastNotes = selected[selected.length - 1].querySelectorAll('.note');
  if (!firstNotes.length || !lastNotes.length) return;
  const startIdx = Math.min(...Array.from(firstNotes).map(n => parseInt(n.dataset.index)));
  const endIdx = Math.max(...Array.from(lastNotes).map(n => parseInt(n.dataset.index)));
  if (isNaN(startIdx) || isNaN(endIdx) || startIdx > endIdx) return;
  const patternLength = endIdx - startIdx + 1;
  const selPattern = noteSteps.slice(startIdx, endIdx + 1).join('');

  const matches = [];
  for (let i = 0; i <= noteSteps.length - patternLength; i++) {
    if (noteSteps.slice(i, i + patternLength).join('') === selPattern) {
      matches.push(i);
    }
  }

  noteElements.forEach(n => n.classList.remove('phrase-highlight'));
  clearPhraseBoxes();
  matches.forEach(pos => {
    for (let i = 0; i < patternLength; i++) {
      const idx = pos + i;
      const el = noteElements[idx];
      if (el) el.classList.add('phrase-highlight');
    }
    drawPhraseBox(pos, pos + patternLength - 1);
  });
}

document.addEventListener("mouseup", () => {
  if (selecting) {
    highlightExactFromSelection();
  }
  selecting = false;
});

document.addEventListener("touchend", () => {
  if (selecting) {
    highlightExactFromSelection();
  }
  selecting = false;
});

document.addEventListener("touchcancel", () => {
  selecting = false;
});

document.addEventListener("keyup", () => {
  highlightExactFromSelection();
});

document.addEventListener("copy", e => {
  const selected = sheetElement.querySelectorAll(".staff.selected");
  if (selected.length) {
    const text = Array.from(selected).map(el => el.dataset.letters || "").join("\n");
    e.clipboardData.setData("text/plain", text);
    e.preventDefault();
  }
});

const phraseSelect = document.getElementById('phraseSelect');
if (phraseSelect) {
  phraseSelect.addEventListener('change', e => highlightPhrase(e.target.value));
}

const runDetectBtn = document.getElementById('runDetect');
  if (runDetectBtn) {
    runDetectBtn.addEventListener('click', () => {
      console.log('runDetect button clicked');
      detectPatternsFromSteps();
      detectDescendingPatterns();
      updateAllPatterns();
      findWinningPatterns();
      showWinningBoxes();
      updatePhraseSelect();
    });
  }
const prevPageBtn = document.getElementById("prevPage");
const nextPageBtn = document.getElementById("nextPage");
let pageHeight = 0;
function updatePageHeight() {
  const controls = document.querySelector(".controls");
  pageHeight = window.innerHeight - (controls ? controls.offsetHeight : 0);
  sheetElement.style.height = pageHeight + "px";
}
updatePageHeight();
window.addEventListener("resize", updatePageHeight);
prevPageBtn.addEventListener("click", () => {
  sheetElement.scrollTop = Math.max(sheetElement.scrollTop - pageHeight, 0);
});
nextPageBtn.addEventListener("click", () => {
  sheetElement.scrollTop = Math.min(sheetElement.scrollTop + pageHeight, sheetElement.scrollHeight - pageHeight);
});


// Recalculate ties whenever layout changes
window.addEventListener('resize', () => {
  if (autoFeaturesEnabled) tieify();
});

if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('service-worker.js');
  });
}
</script>
</html>
